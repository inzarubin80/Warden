# ТЗ: ЭкоМонитор — мобильное приложение и сервер (Go)

Цель
Создать мобильное приложение для Android и iOS и сервер на Go для фиксации, подтверждения и отслеживания экологических нарушений с поддержкой фото, офлайн‑кэша, push‑уведомлений и авторизацией через OAuth (VK, Yandex). Медиа — в S3.

Область работ
- Мобильный клиент: React Native (или аналог) ориентированный на мобильный браузер/встроенный WebView и нативные контейнеры; UI как в примере.
- Сервер: Go (REST/JSON + WebSocket для реального времени), PostgreSQL, Redis (кэш/очереди), S3‑совместимое хранилище.
- Инфраструктура: Docker, k8s или docker‑compose, CI/CD (GitHub Actions/GitLab CI).

Мобильный клиент (функциональные требования)
- Платформы: Android и iOS.
- Главные экраны: Карта, Форма сообщения, Список нарушений, Экран поддержки (донаты), Детали нарушения.
- Карта: маркеры нарушений, геолокация, тап для выбора точки, кластеризация маркеров.
- Форма сообщения: выбор типа нарушения, текст, мультизагрузка фото, автозаполнение координат, предварительный просмотр фото.
- Статусы: New, Confirmed, Resolved. Пользователь может подтверждать и отслеживать статус.
- Аутентификация: OAuth через VK и Yandex, опционально сохранение локального токена (JWT).
- Offline: локальное хранение (SQLite/Realm) записей, очередь на синхронизацию при сети; стратегия конфликтов: last‑write‑wins + метки времени и server‑assigned ids.
- Push: APNs и FCM для уведомлений о статусах/комментариях/подтверждениях.
- UI/UX: адаптивный мобильный интерфейс по предоставленному макету; поддержка загрузки нескольких фото и preview; минимальная доступность.

Сервер (функциональные требования)
- Язык: Go (1.20+). Стек: net/http или Gin/Fiber, GORM/ent/sqlx, pgx.
- БД: PostgreSQL — таблицы users, violations, photos, confirmations, notifications, sessions.
- Ключевые API:
  - POST /auth/oauth/{provider}/callback — обмен кода на токен и выдача JWT
  - GET /me — профиль
  - POST /violations — создать нарушение (координаты, тип, описание, ссылки на фото)
  - GET /violations — список (фильтры: bbox, type, status, date)
  - GET /violations/{id} — детали
  - POST /violations/{id}/confirm — подтвердить
  - POST /violations/{id}/resolve — отметить устраненным (с фото)
  - POST /upload — пред‑подпись/инициация upload в S3 (presigned URL)
  - WS /realtime — подписка на обновления (новые/изменённые нарушения)
- Медиа: загрузка через presigned URLs в S3; сервер хранит метаданные (photo url, size, mime).
- Очереди/фоновые задачи: обработка изображений (ресайз, webp), модерация (опционально), отправка push‑уведомлений.
- Авторизация/аутентификация: OAuth VK + Yandex, привязка к internal user record; сессии через JWT (access + refresh).
- Безопасность: валидация входных данных, rate limiting, проверка MIME при загрузке в S3, CORS.

Модели данных (ключевые поля)

- User
  - `id`: уникальный идентификатор пользователя (UUID).
  - `provider`: поставщик аутентификации (например, `vk`, `yandex`).
  - `provider_id`: идентификатор пользователя у провайдера OAuth (строка).
  - `name`: отображаемое имя пользователя.
  - `email`: адрес электронной почты (опционально, может отсутствовать для некоторых OAuth-провайдеров).
  - `avatar_url`: публичная ссылка на аватар пользователя (S3/URL).
  - `created_at`: отметка времени создания записи (ISO 8601).

- Violation
  - `id`: уникальный идентификатор нарушения (UUID).
  - `user_id`: внешний ключ на автора сообщения (`User.id`).
  - `type`: тип нарушения (enum: `garbage`, `pollution`, `air`, `deforestation`, `other`).
  - `description`: подробное текстовое описание проблемы.
  - `lat`: широта места нарушения (decimal, WGS84).
  - `lng`: долгота места нарушения (decimal, WGS84).
  - `status`: текущий статус нарушения (enum: `new`, `confirmed`, `resolved`).
  - `confirmations_count`: целое число — количество подтверждений от других пользователей.
  - `created_at`: время создания записи (ISO 8601).
  - `updated_at`: время последнего изменения (ISO 8601).

- Photo
  - `id`: уникальный идентификатор фотографии (UUID).
  - `violation_id`: внешний ключ на нарушение (`Violation.id`).
  - `url`: публичная или пред-подписанная ссылка для доступа к изображению.
  - `storage_key`: внутренний ключ/путь в S3 (используется для удаления/манипуляций).
  - `mime`: MIME‑тип файла (например, `image/jpeg`).
  - `size`: размер файла в байтах.
  - `created_at`: время загрузки фотографии (ISO 8601).

- Confirmation
  - `id`: уникальный идентификатор подтверждения (UUID).
  - `violation_id`: внешний ключ на нарушение (`Violation.id`).
  - `user_id`: внешний ключ на пользователя, который подтвердил нарушение (`User.id`).
  - `created_at`: время подтверждения (ISO 8601).

- Notification
  - `id`: уникальный идентификатор уведомления (UUID).
  - `user_id`: внешний ключ на пользователя, для которого предназначено уведомление (`User.id`).
  - `type`: тип уведомления (например, `violation_updated`, `confirmation`, `admin_message`).
  - `payload`: JSON‑объект с полезной нагрузкой (детали события — ссылка на нарушение, текст и т.п.).
  - `read`: булево поле — помечено ли уведомление как прочитанное.
  - `created_at`: время создания уведомления (ISO 8601).

Оффлайн/синхронизация
- На клиенте: локальная БД (SQLite/WatermelonDB/Realm). Все операции помещаются в локальную очередь.
- При восстановлении связи: синхронизировать очередь по API /violations (POST) и получать серверную копию с server‑id и timestamps.
- Разрешение конфликтов: server authoritative for ids; last‑write‑wins на поле updated_at; при конфликте показывать пользователю вариант с возможностью ручного выбора (opt-in).

Push‑уведомления
- Сервер отправляет через FCM/APNs при изменении статуса, подтверждении (>0) или комментариях.
- Хранить device_tokens в таблице devices связанной с user.

Админка
- Веб‑панель для модерации нарушений, удаления фейков, просмотра статистики и управления пользователями.
- Endpoints: /admin/violations, /admin/users, /admin/stats.

Инфраструктура и развертывание
- Dockerfiles для server и worker; docker‑compose (dev) и k8s manifests (prod).
- Сервисы: postgres, redis, minio (или AWS S3), reverse proxy (nginx), cert‑manager/Let's Encrypt.
- Хранение секретов: Vault/Secrets Manager / k8s secrets.

CI/CD и тесты
- Линтеры и форматтеры (golangci‑lint, go fmt), unit и интеграционные тесты; E2E для мобильного приложения (Detox/Appium).
- Pipeline: build → test → build docker image → push → deploy (staging → prod).

Мониторинг и логирование
- Логи: structured JSON (zap/logrus), централизованный сбор (ELK/Cloudwatch).
- Метрики: Prometheus + Grafana, alerting на 5xx/queue backlog/failed jobs.

Безопасность и соответствие
- Хранить минимальный набор персональных данных, шифрование S3 (server‑side), политика удаления данных.
- Лимит на размер и количество загружаемых фото, проверка форматов.

Оценка сроков (ориентировочно, команда 2‑3 dev)
- Архитектура, API и infra setup: 1–2 недели
- Базовый Go‑сервер: 2–3 недели
- Мобильный клиент (карта, форма, локальное хранение, sync): 3–4 недели
- Push, WebSocket, фоновые задачи, админка: 2–3 недели
- Тесты, CI/CD, деплой: 1–2 недели
- Итого MVP: ~8–12 недель


Риски и рекомендации
- OAuth (VK/Yandex) требует регистрации приложений и корректных redirect URIs.
- Тестирование оффлайн‑режима требует реальных устройств.
- Контроль затрат на S3 и политика хранения медиа.

Права доступа, workflow подтверждения/закрытия и таблица правил

Ниже предлагается формализованный подход к обработке нарушений: блок‑схема процесса, таблица правил в БД и примеры правил для MVP. Это позволяет централизованно менять логику подтверждений/закрытий без перекомпиляции сервера.

Диаграмма процесса (Mermaid)
```mermaid
flowchart TD
  NewReport[Новая заявка]
  Validate[Валидация (фото, coords)]
  Dedup[Дедупликация по GEO/контексту]
  Store[Сохранить как New]
  NotifyMods[Уведомить модераторов]
  Confirmations[Накопление подтверждений]
  CheckConfirm{Подтверждений >= threshold?}
  SetConfirmed[Статус = Confirmed]
  ProposeResolve[Пользователь: предложить закрытие]
  EvidenceCheck[Проверка доказательств (photo/meta)]
  ModeratorReview[Модератор проверяет]
  ApproveResolve[Закрыть -> Resolved]
  AutoResolve[Авто‑правило -> Resolved]

  NewReport --> Validate --> Dedup --> Store --> NotifyMods --> Confirmations
  Confirmations --> CheckConfirm
  CheckConfirm -- yes --> SetConfirmed
  CheckConfirm -- no --> Confirmations
  Store --> ProposeResolve
  ProposeResolve --> EvidenceCheck --> ModeratorReview --> ApproveResolve
  EvidenceCheck -->|rules allow| AutoResolve --> ApproveResolve
```

Таблица правил (минимальная схема)
```sql
CREATE TABLE violation_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  trigger_event TEXT NOT NULL,         -- e.g. 'confirmation','propose_resolve','create'
  condition JSONB NULL,                -- фильтр / выражение (проверяется на событии)
  threshold INT NULL,                  -- порог (количество подтверждений или суммарный вес)
  weight_map JSONB NULL,               -- {"guest":1,"user":1,"moderator":5}
  action TEXT NOT NULL,                -- e.g. 'set_status','auto_resolve','notify'
  action_params JSONB NULL,
  active BOOLEAN DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
```

Примеры правил для MVP
```sql
-- 1) Стандартный порог подтверждений
INSERT INTO violation_rules (name, trigger_event, threshold, action, action_params)
VALUES ('confirmation_threshold_default', 'confirmation', 3, 'set_status', '{"status":"confirmed"}');

-- 2) Подтверждение модератором сразу переводит в confirmed
INSERT INTO violation_rules (name, trigger_event, condition, threshold, action, action_params)
VALUES ('moderator_override', 'confirmation', '{"actor_role":"moderator"}', 1, 'set_status', '{"status":"confirmed"}');

-- 3) Предложение закрытия требует минимум 1 фото (правило валидации/направление на модерацию)
INSERT INTO violation_rules (name, trigger_event, condition, action, action_params)
VALUES ('propose_requires_photo', 'propose_resolve', '{"min_photos":1}', 'set_resolution_status', '{"status":"proposed"}');

-- 4) (опционально, для v2) Авто‑закрытие автора при 2 фото и 2 подтверждения — оставить неактивным в MVP
INSERT INTO violation_rules (name, trigger_event, condition, threshold, action, action_params, active)
VALUES ('auto_resolve_author', 'propose_resolve', '{"author_is_reporter":true, "min_photos":2}', 2, 'auto_resolve', '{}', false);
```

Псевдо‑логика движка правил (кратко)
- На событие (confirmation / propose_resolve / create) движок делает:
  1) Загружает все `active` правила с `trigger_event = event.type`.
  2) Для каждого правила проверяет `condition` JSON против `event.payload` (поддержать в MVP ключи: `actor_role`, `min_photos`, `author_is_reporter`).
  3) Вычисляет значение (например, количество уникальных подтверждений) и сравнивает с `threshold`.
  4) При срабатывании выполняет `action` (например, `set_status`, `set_resolution_status`, `auto_resolve`, `notify`).
  5) Логирует сработавшие правила в `audit_logs`.

Рекомендации для MVP
- Ограничить набор правил 2–3 штуки и реализовать простой движок, поддерживающий базовые условия.
- Не включать авто‑закрытие в MVP (ставить такие правила `active = false`).
- Собрать данные об использовании (сколько предложений, сколько модераторских закрытий) — затем расширять правила.


