# ТЗ: ЭкоМонитор — мобильное приложение и сервер (Go)

Цель
Создать мобильное приложение для Android и iOS и сервер на Go для фиксации, подтверждения и отслеживания экологических нарушений с поддержкой фото, офлайн‑кэша, push‑уведомлений и авторизацией через OAuth (VK, Yandex). Медиа — в S3.

Область работ
- Мобильный клиент: React Native (или аналог) ориентированный на мобильный браузер/встроенный WebView и нативные контейнеры; UI как в примере.
- Сервер: Go (REST/JSON + WebSocket для реального времени), PostgreSQL, Redis (кэш/очереди), S3‑совместимое хранилище.
- Инфраструктура: Docker, k8s или docker‑compose, CI/CD (GitHub Actions/GitLab CI).

Мобильный клиент (функциональные требования)
- Платформы: Android и iOS.
- Главные экраны: Карта, Форма сообщения, Список нарушений, Экран поддержки (донаты), Детали нарушения.
- Карта: маркеры нарушений, геолокация, тап для выбора точки, кластеризация маркеров.
- Форма сообщения: выбор типа нарушения, текст, мультизагрузка фото, автозаполнение координат, предварительный просмотр фото.
- Статусы: New, Confirmed, Resolved. Пользователь может подтверждать и отслеживать статус.
- Аутентификация: OAuth через VK и Yandex, опционально сохранение локального токена (JWT).
- Offline: локальное хранение (SQLite/Realm) записей, очередь на синхронизацию при сети; стратегия конфликтов: last‑write‑wins + метки времени и server‑assigned ids.
- Push: APNs и FCM для уведомлений о статусах/комментариях/подтверждениях.
- UI/UX: адаптивный мобильный интерфейс по предоставленному макету; поддержка загрузки нескольких фото и preview; минимальная доступность.

Сервер (функциональные требования)
- Язык: Go (1.20+). Стек: net/http; использовать только библиотеки, присутствующие в проекте `server/go.mod`: `github.com/jackc/pgx/v5` (PostgreSQL driver), `github.com/google/uuid`, `github.com/go-ozzo/ozzo-validation`, `github.com/golang-jwt/jwt`, `github.com/gorilla/sessions`, `github.com/gorilla/websocket`, `github.com/joho/godotenv`, `github.com/rs/cors`, `golang.org/x/oauth2`.
- БД: PostgreSQL — таблицы users, violations, photos, confirmations, notifications, sessions.
- Ключевые API:
  - POST /auth/oauth/{provider}/callback — обмен кода на токен и выдача JWT
  - GET /me — профиль
  - POST /violations — создать нарушение (координаты, тип, описание, ссылки на фото)
  - GET /violations — список (фильтры: bbox, type, status, date)
  - GET /violations/{id} — детали
  - POST /violations/{id}/confirm — подтвердить
  - POST /violations/{id}/resolve — отметить устраненным (с фото)
  - POST /upload — пред‑подпись/инициация upload в S3 (presigned URL)
  - WS /realtime — подписка на обновления (новые/изменённые нарушения)
- Медиа: загрузка через presigned URLs в S3; сервер хранит метаданные (photo url, size, mime).
- Очереди/фоновые задачи: обработка изображений (ресайз, webp), модерация (опционально), отправка push‑уведомлений.
- Авторизация/аутентификация: OAuth VK + Yandex, привязка к internal user record; сессии через JWT (access + refresh).
- Безопасность: валидация входных данных, rate limiting, проверка MIME при загрузке в S3, CORS.

Модели данных (ключевые поля)

 - User
  - `id`: уникальный идентификатор пользователя (UUID).
  - `name`: отображаемое имя пользователя.
  - `email`: адрес электронной почты (опционально).
  - `avatar_url`: публичная ссылка на аватар пользователя (S3/URL).
  - `created_at`: отметка времени создания записи (ISO 8601).
  - Примечание: связи с провайдерами аутентификации вынесены в отдельную таблицу `user_auth_providers` (m:n — один пользователь может иметь несколько провайдеров).

 - UserAuthProvider
  - `user_id`: внешний ключ на `User.id` (UUID).
  - `provider_uid`: идентификатор пользователя у провайдера OAuth (строка).
  - `provider`: поставщик аутентификации (например, `vk`, `yandex`).
  - `name`: имя/никнейм от провайдера (опционально).
  - `created_at`: отметка времени привязки (ISO 8601).

Пример SQL (миграция) — вариант для PostgreSQL (адаптирован по примеру из репозитория):

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  email TEXT,
  avatar_url TEXT,
  created_at timestamptz DEFAULT now()
);

CREATE TABLE user_auth_providers (
  user_id UUID NOT NULL REFERENCES users(id),
  provider_uid VARCHAR(255) NOT NULL,
  provider VARCHAR(50) NOT NULL,
  name VARCHAR(255),
  created_at timestamptz DEFAULT now(),
  PRIMARY KEY (provider_uid, provider)
);
```

Пример Go‑структур (используя `github.com/google/uuid`):

```go
type User struct {
  ID        uuid.UUID `db:"id" json:"id"`
  Name      string    `db:"name" json:"name"`
  Email     *string   `db:"email" json:"email,omitempty"`
  AvatarURL *string   `db:"avatar_url" json:"avatar_url,omitempty"`
  CreatedAt time.Time `db:"created_at" json:"created_at"`
}

type UserAuthProvider struct {
  UserID      uuid.UUID `db:"user_id" json:"user_id"`
  ProviderUID string    `db:"provider_uid" json:"provider_uid"`
  Provider    string    `db:"provider" json:"provider"`
  Name        *string   `db:"name" json:"name,omitempty"`
  CreatedAt   time.Time `db:"created_at" json:"created_at"`
}
```

Короткая подсказка по использованию: при OAuth callback —
1) искать существующую запись в `user_auth_providers` по `(provider, provider_uid)`;
2) если найдена — вернуть связанного `User`; если нет — создать `User` и вставить запись в `user_auth_providers`.

- Violation
  - `id`: уникальный идентификатор нарушения (UUID).
  - `user_id`: внешний ключ на автора сообщения (`User.id`).
  - `type`: тип нарушения (enum: `garbage`, `pollution`, `air`, `deforestation`, `other`).
  - `description`: подробное текстовое описание проблемы.
  - `lat`: широта места нарушения (decimal, WGS84).
  - `lng`: долгота места нарушения (decimal, WGS84).
  - `status`: текущий статус нарушения (enum: `new`, `confirmed`, `resolved`).
  - `confirmations_count`: целое число — количество подтверждений от других пользователей.
  - `created_at`: время создания записи (ISO 8601).
  - `updated_at`: время последнего изменения (ISO 8601).

- Photo
  - `id`: уникальный идентификатор фотографии (UUID).
  - `violation_id`: внешний ключ на нарушение (`Violation.id`).
  - `url`: публичная или пред-подписанная ссылка для доступа к изображению.
  - `storage_key`: внутренний ключ/путь в S3 (используется для удаления/манипуляций).
  - `mime`: MIME‑тип файла (например, `image/jpeg`).
  - `size`: размер файла в байтах.
  - `created_at`: время загрузки фотографии (ISO 8601).

- Confirmation
  - `id`: уникальный идентификатор подтверждения (UUID).
  - `violation_id`: внешний ключ на нарушение (`Violation.id`).
  - `user_id`: внешний ключ на пользователя, который подтвердил нарушение (`User.id`).
  - `created_at`: время подтверждения (ISO 8601).

- Notification
  - `id`: уникальный идентификатор уведомления (UUID).
  - `user_id`: внешний ключ на пользователя, для которого предназначено уведомление (`User.id`).
  - `type`: тип уведомления (например, `violation_updated`, `confirmation`, `admin_message`).
  - `payload`: JSON‑объект с полезной нагрузкой (детали события — ссылка на нарушение, текст и т.п.).
  - `read`: булево поле — помечено ли уведомление как прочитанное.
  - `created_at`: время создания уведомления (ISO 8601).

Оффлайн/синхронизация
- На клиенте: локальная БД (SQLite/WatermelonDB/Realm). Все операции помещаются в локальную очередь.
- При восстановлении связи: синхронизировать очередь по API /violations (POST) и получать серверную копию с server‑id и timestamps.
- Разрешение конфликтов: server authoritative for ids; last‑write‑wins на поле updated_at; при конфликте показывать пользователю вариант с возможностью ручного выбора (opt-in).

Push‑уведомления
- Сервер отправляет через FCM/APNs при изменении статуса, подтверждении (>0) или комментариях.
- Хранить device_tokens в таблице devices связанной с user.

Админка
- Веб‑панель для модерации нарушений, удаления фейков, просмотра статистики и управления пользователями.
- Endpoints: /admin/violations, /admin/users, /admin/stats.

Инфраструктура и развертывание
- Dockerfiles для server и worker; docker‑compose (dev) и k8s manifests (prod).
- Сервисы: postgres, redis, minio (или AWS S3), reverse proxy (nginx), cert‑manager/Let's Encrypt.
- Хранение секретов: Vault/Secrets Manager / k8s secrets.

CI/CD и тесты
- Линтеры и форматтеры (golangci‑lint, go fmt), unit и интеграционные тесты; E2E для мобильного приложения (Detox/Appium).
- Pipeline: build → test → build docker image → push → deploy (staging → prod).

Мониторинг и логирование
- Логи: structured JSON (zap/logrus), централизованный сбор (ELK/Cloudwatch).
- Метрики: Prometheus + Grafana, alerting на 5xx/queue backlog/failed jobs.

Безопасность и соответствие
- Хранить минимальный набор персональных данных, шифрование S3 (server‑side), политика удаления данных.
- Лимит на размер и количество загружаемых фото, проверка форматов.

Модерация (ML‑помощь: `nsfw_detector`, `detoxify`)

Реализуется как отдельный микросервис на Python (FastAPI) — воркер/сервис модерации отвечает за запуск ML‑моделей, правила порогов и очередь модерации; взаимодействие с основным Go‑сервером через очередь (Redis) и внутренние HTTP/gRPC эндпоинты.

Кратко: используем лёгкую гибридную схему — автоматическая предобработка + ML‑сканирование (images → `nsfw_detector`, text → `detoxify`) → пороговая логика → действие (auto‑approve / pending_moderation / auto_reject). Исходные медиа хранятся приватно до одобрения.

Пайплайн:
1. Клиент создаёт репорт и загружает фото/текст. Сервер сохраняет медиа во временный приватный S3 (private) и возвращает report_id.
2. Worker забирает задачу, запускает:
   - image NSFW detector (`nsfw_detector`) → `score_image` (0..1)
   - text toxicity detector (`detoxify`) → `score_text` (0..1)
3. Комбинация: `score = max(score_image, score_text)`
4. Правила (рекомендация):
   - `score < 0.3` → auto_approve (статус `new`, публикуется)
   - `0.3 ≤ score < 0.7` → `pending_moderation` (помечается для ручной проверки)
   - `score ≥ 0.7` → auto_reject / flag (стоп, требует срочного рассмотрения)
5. Модератор в админке принимает решение по `pending_moderation`; действие логируется в `audit_logs`.
6. После approve делаем медиа публичным (или выдаём presigned URL), при reject — удаляем/архивируем и логируем причину.

Рекомендуемые изменения в БД:
```sql
ALTER TABLE violations ADD COLUMN moderation_status TEXT DEFAULT 'none';
ALTER TABLE violations ADD COLUMN moderation_score FLOAT;
ALTER TABLE violations ADD COLUMN moderation_reason TEXT;
ALTER TABLE violations ADD COLUMN moderated_by UUID;
ALTER TABLE violations ADD COLUMN moderated_at timestamptz;
```

Примеры (быстро):

Image (`nsfw_detector`):
```python
from nsfw_detector import predict
model = predict.load_model('nsfw_model.h5')
scores = model.predict('upload.jpg')  # returns dict
score_image = scores['upload.jpg'].get('porn',0) + scores['upload.jpg'].get('sexy',0)
```

Text (`detoxify`):
```python
from detoxify import Detoxify
res = Detoxify('original').predict("пользовательский текст")
score_text = max(res.values())  # toxic, severe_toxic, obscene...
```

Объединение и решение:
```python
score = max(score_image, score_text)
if score < 0.3:
    status = 'approved'
elif score < 0.7:
    status = 'pending_moderation'
else:
    status = 'rejected'
```

Практические рекомендации:
- Запускать ML в отдельном worker'е (Celery/RQ/Sidekiq) чтобы не блокировать основной API.
- Хранить исходные файлы приватно и публиковать только после одобрения.
- Собрать и сохранять метки модераторов (approved/rejected + reason) для обучения модели позже.
- Начать с консервативных порогов, мониторить false positives/negatives и корректировать.
- Для доверенных пользователей можно понижать пороги авто‑публикации (reputation based).

Юридические примечания:
- Для явно незаконного контента (CSAM, угрозы, экстремизм) — немедленная блокировка и логирование с возможностью эскалации в МВД/юридический отдел.

Оценка сроков (ориентировочно, команда 2‑3 dev)
- Архитектура, API и infra setup: 1–2 недели
- Базовый Go‑сервер: 2–3 недели
- Мобильный клиент (карта, форма, локальное хранение, sync): 3–4 недели
- Push, WebSocket, фоновые задачи, админка: 2–3 недели
- Тесты, CI/CD, деплой: 1–2 недели
- Итого MVP: ~8–12 недель


Риски и рекомендации
- OAuth (VK/Yandex) требует регистрации приложений и корректных redirect URIs.
- Тестирование оффлайн‑режима требует реальных устройств.
- Контроль затрат на S3 и политика хранения медиа.

Права доступа, workflow подтверждения/закрытия и таблица правил

Ниже предлагается формализованный подход к обработке нарушений: блок‑схема процесса, таблица правил в БД и примеры правил для MVP. Это позволяет централизованно менять логику подтверждений/закрытий без перекомпиляции сервера.

Диаграмма процесса (Mermaid)
```mermaid
flowchart TD
  NewReport[Новая заявка]
  Validate[Валидация (фото, coords)]
  Dedup[Дедупликация по GEO/контексту]
  Store[Сохранить как New]
  NotifyMods[Уведомить модераторов]
  Confirmations[Накопление подтверждений]
  CheckConfirm{Подтверждений >= threshold?}
  SetConfirmed[Статус = Confirmed]
  ProposeResolve[Пользователь: предложить закрытие]
  EvidenceCheck[Проверка доказательств (photo/meta)]
  ModeratorReview[Модератор проверяет]
  ApproveResolve[Закрыть -> Resolved]
  AutoResolve[Авто‑правило -> Resolved]

  NewReport --> Validate --> Dedup --> Store --> NotifyMods --> Confirmations
  Confirmations --> CheckConfirm
  CheckConfirm -- yes --> SetConfirmed
  CheckConfirm -- no --> Confirmations
  Store --> ProposeResolve
  ProposeResolve --> EvidenceCheck --> ModeratorReview --> ApproveResolve
  EvidenceCheck -->|rules allow| AutoResolve --> ApproveResolve
```

Сценарий (пошаговое текстовое описание процесса)

1) Пользователь создает новый отчёт (NewReport): заполняет тип нарушения, описание, указывает координаты и прикрепляет фото.

2) Валидация на сервере/клиенте (Validate): проверяются наличие минимального набора данных (координаты, хотя бы одно фото при требовании), корректность форматов и MIME, размеры файлов и базовая валидация полей. Некорректные или неполные отчёты отклоняются с сообщением пользователю.

3) Дедупликация (Dedup): сервер пытается найти существующие записи рядом по геокоординатам/времени/контенту фото; если найдено похожее нарушение — система может предложить привязать к существующей записи или создать новую в зависимости от политики дедупликации.

4) Сохранение как «New» (Store): если отчёт считается новым — создаётся запись в БД с статусом `new`, сохраняются метаданные фото (URL/ключ в S3, MIME, размер), и фиксируются временные метки.

5) Уведомление модераторов (NotifyMods): при необходимости (по правилам) отправляются уведомления модераторам/админам для проверки; одновременно инициируется сбор подтверждений от других пользователей.

6) Накопление подтверждений (Confirmations): другие пользователи видят заявку и могут подтвердить её. Каждое подтверждение логируется и увеличивает счётчик `confirmations_count`.

7) Проверка порога подтверждений (CheckConfirm): движок правил проверяет, достигнуто ли заданное число подтверждений или сумма весов — если да, статус меняется на `confirmed` (SetConfirmed); если нет — заявка остаётся в ожидании дальнейших подтверждений.

8) Предложение закрытия (ProposeResolve): автор или другой пользователь может предложить закрыть нарушение, прикрепив новые фото/доказательства; это переводит запись в состояние проверки на предмет достаточности доказательств.

9) Проверка доказательств (EvidenceCheck): система/модератор проверяет наличие обязательных атрибутов (например, минимум фото) и применяет правила (validation / business rules). Если правило для авто‑закрытия сработало и условия выполнены — может быть инициировано AutoResolve.

10) Модераторский обзор (ModeratorReview): при необходимости модератор вручную проверяет заявку и доказательства и принимает решение: одобрить закрытие (ApproveResolve) или оставить на доработку/отклонить.

11) Закрытие (ApproveResolve / AutoResolve): после одобрения модератором или срабатывания авто‑правила статус меняется на `resolved`. Система отправляет уведомления владельцу и участникам, логирует событие и обновляет метрики.

12) Логирование и аудит: все ключевые события (создание, подтверждение, изменение статуса, модераторские действия) записываются в `audit_logs` для последующего разбора и аналитики.

Пояснения и примечания:
- Оффлайн‑режим клиента: при отсутствии сети клиент кэширует заявку и синхронизирует при восстановлении соединения; при синхронизации применяется дедупликация и конфликт‑революция по `updated_at` (server authoritative).
- Правила дедупликации и пороги подтверждений настраиваются через таблицу правил (`violation_rules`) и могут различаться по типу нарушения и роли актёра.
- Безопасность: при загрузке фото сервер проверяет MIME, размеры и лимиты по количеству/объёму; крупные объёмы направляются в фоновые задачи для обработки (resize, webp).
- Уведомления: пользователи получают push/внутренние уведомления о смене статуса, подтверждениях и решениях модерации.

Таблица правил (минимальная схема)
```sql
CREATE TABLE violation_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  trigger_event TEXT NOT NULL,         -- e.g. 'confirmation','propose_resolve','create'
  condition JSONB NULL,                -- фильтр / выражение (проверяется на событии)
  threshold INT NULL,                  -- порог (количество подтверждений или суммарный вес)
  weight_map JSONB NULL,               -- {"guest":1,"user":1,"moderator":5}
  action TEXT NOT NULL,                -- e.g. 'set_status','auto_resolve','notify'
  action_params JSONB NULL,
  active BOOLEAN DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
```

Примеры правил для MVP
```sql
-- 1) Стандартный порог подтверждений
INSERT INTO violation_rules (name, trigger_event, threshold, action, action_params)
VALUES ('confirmation_threshold_default', 'confirmation', 3, 'set_status', '{"status":"confirmed"}');

-- 2) Подтверждение модератором сразу переводит в confirmed
INSERT INTO violation_rules (name, trigger_event, condition, threshold, action, action_params)
VALUES ('moderator_override', 'confirmation', '{"actor_role":"moderator"}', 1, 'set_status', '{"status":"confirmed"}');

-- 3) Предложение закрытия требует минимум 1 фото (правило валидации/направление на модерацию)
INSERT INTO violation_rules (name, trigger_event, condition, action, action_params)
VALUES ('propose_requires_photo', 'propose_resolve', '{"min_photos":1}', 'set_resolution_status', '{"status":"proposed"}');

-- 4) (опционально, для v2) Авто‑закрытие автора при 2 фото и 2 подтверждения — оставить неактивным в MVP
INSERT INTO violation_rules (name, trigger_event, condition, threshold, action, action_params, active)
VALUES ('auto_resolve_author', 'propose_resolve', '{"author_is_reporter":true, "min_photos":2}', 2, 'auto_resolve', '{}', false);
```

Псевдо‑логика движка правил (кратко)
- На событие (confirmation / propose_resolve / create) движок делает:
  1) Загружает все `active` правила с `trigger_event = event.type`.
  2) Для каждого правила проверяет `condition` JSON против `event.payload` (поддержать в MVP ключи: `actor_role`, `min_photos`, `author_is_reporter`).
  3) Вычисляет значение (например, количество уникальных подтверждений) и сравнивает с `threshold`.
  4) При срабатывании выполняет `action` (например, `set_status`, `set_resolution_status`, `auto_resolve`, `notify`).
  5) Логирует сработавшие правила в `audit_logs`.

Рекомендации для MVP
- Ограничить набор правил 2–3 штуки и реализовать простой движок, поддерживающий базовые условия.
- Не включать авто‑закрытие в MVP (ставить такие правила `active = false`).
- Собрать данные об использовании (сколько предложений, сколько модераторских закрытий) — затем расширять правила.


